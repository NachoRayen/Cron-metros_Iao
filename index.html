<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cronómetro de Bosses - Imperium AO</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');

    :root {
      --gold: #D4AF37;
      --blue: #004E8A;
      --lightblue: #4FC3F7;
      --darkblue: #002F4B;
      --green: #4CAF50;
      --red: #D32F2F;
      --background-light: #F9F6F1;
      --background-dark: #0D1B2A;
      --text-light: #222;
      --text-dark: #EEE;
    }

    body {
      margin: 0;
      font-family: 'MedievalSharp', cursive, serif;
      background-color: var(--background-light);
      color: var(--text-light);
      background-image: url('imperium_logo_grande.png'); /* Coloca el logo en la misma carpeta */
      background-repeat: no-repeat;
      background-position: center;
      background-size: 400px auto;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      align-items: center;
      padding: 1rem;
    }

    body.dark {
      background-color: var(--background-dark);
      color: var(--text-dark);
      background-image: url('imperium_logo_grande.png');
      background-position: center;
      background-size: 400px auto;
    }

    header {
      width: 100%;
      max-width: 900px;
      margin-bottom: 1rem;
      text-align: center;
      border-bottom: 2px solid var(--gold);
      padding-bottom: 0.5rem;
      font-size: 2rem;
      color: var(--gold);
      text-shadow: 1px 1px 2px #0008;
    }

    #loginForm, #logoutSection {
      max-width: 400px;
      background: var(--lightblue);
      padding: 1rem;
      border-radius: 8px;
      box-shadow: 0 0 10px #0003;
      margin-bottom: 1rem;
      color: var(--darkblue);
      font-weight: bold;
    }

    #loginForm.dark, #logoutSection.dark {
      background: #033963cc;
      color: var(--lightblue);
      box-shadow: 0 0 15px #4fc3f7cc;
    }

    input[type="email"],
    input[type="password"],
    input[type="text"] {
      width: 100%;
      padding: 8px;
      margin: 0.5rem 0 1rem 0;
      border: 2px solid var(--gold);
      border-radius: 4px;
      font-size: 1rem;
      font-family: 'MedievalSharp', cursive;
    }

    input[type="email"]:focus,
    input[type="password"]:focus,
    input[type="text"]:focus {
      border-color: var(--lightblue);
      outline: none;
    }

    button {
      background-color: var(--gold);
      border: none;
      color: #111;
      font-weight: 700;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-family: 'MedievalSharp', cursive;
      transition: background-color 0.3s ease;
      box-shadow: 0 0 5px #d4af3777;
      user-select: none;
    }

    button:hover {
      background-color: #b38f22;
      box-shadow: 0 0 10px #d4af37cc;
    }

    #themeToggleBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 100;
    }

    #filterBossesBtn {
      margin-bottom: 1rem;
    }

    #searchInput {
      width: 250px;
      padding: 6px 8px;
      margin-right: 1rem;
      font-family: 'MedievalSharp', cursive;
      font-size: 1rem;
      border: 2px solid var(--gold);
      border-radius: 5px;
    }

    .timer-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 900px;
      gap: 1rem;
      width: 100%;
    }

    .timer {
      background-color: var(--darkblue);
      color: var(--text-dark);
      border-radius: 10px;
      padding: 1rem;
      width: 260px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 3px solid var(--gold);
      box-shadow: 0 0 10px #0009;
      position: relative;
      font-size: 1.1rem;
    }

    body.dark .timer {
      background-color: var(--blue);
      color: var(--gold);
      border-color: var(--lightblue);
      box-shadow: 0 0 15px var(--lightblue);
    }

    .timer.beforeSpawn {
      background-color: var(--darkblue);
      border-color: var(--blue);
      color: var(--lightblue);
      animation: none;
    }

    .timer.canSpawn {
      background-color: var(--lightblue);
      border-color: var(--gold);
      color: var(--darkblue);
      animation: pulseFire 1.5s infinite alternate;
    }

    .timer.spawned {
      background-color: var(--red);
      border-color: var(--gold);
      color: var(--background-light);
      animation: pulseWarning 1.5s infinite alternate;
    }

    .timer.spawnedActive {
      background-color: var(--green);
      border-color: var(--gold);
      color: var(--background-light);
      animation: none;
    }

    @keyframes pulseFire {
      0% { box-shadow: 0 0 15px 5px #ff4500cc; }
      100% { box-shadow: 0 0 25px 10px #ffae0088; }
    }

    @keyframes pulseWarning {
      0% { box-shadow: 0 0 15px 5px #ffcc00cc; }
      100% { box-shadow: 0 0 25px 10px #ffcc0099; }
    }

    .timer h2 {
      margin: 0 0 0.5rem 0;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .timer-icon {
      font-size: 1.6rem;
      animation: none;
      user-select: none;
    }

    .canSpawn .timer-icon {
      animation: flameBlink 1.5s infinite alternate;
      color: #ff4500;
    }

    .spawned .timer-icon {
      animation: warningBlink 1.5s infinite alternate;
      color: #ffcc00;
    }

    @keyframes flameBlink {
      0% { opacity: 1; }
      100% { opacity: 0.3; }
    }

    @keyframes warningBlink {
      0% { opacity: 1; }
      100% { opacity: 0.3; }
    }

    .respawn-time {
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
      font-style: italic;
      color: var(--gold);
    }

    .timer-time {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 1rem;
      user-select: none;
    }

    .input-group {
      display: flex;
      width: 100%;
      gap: 0.5rem;
      justify-content: center;
    }

    .death-time-input {
      flex-grow: 1;
      padding: 6px;
      border-radius: 4px;
      border: 2px solid var(--gold);
      font-family: 'MedievalSharp', cursive;
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
    }

    .btn-murio {
      background-color: var(--gold);
      color: var(--darkblue);
      font-weight: 700;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      padding: 6px 10px;
      user-select: none;
      transition: background-color 0.3s ease;
    }

    .btn-murio:hover {
      background-color: #b38f22;
    }

    /* Scroll barra para timer container si es necesario */
    .timer-container {
      max-height: 75vh;
      overflow-y: auto;
    }

  </style>
</head>
<body>

  <header>Cronómetro de Bosses - Imperium AO</header>

  <button id="themeToggleBtn" onclick="toggleTheme()">Cambiar Tema</button>

  <div id="loginForm">
    <h3>Iniciar Sesión / Registrarse</h3>
    <input type="email" id="emailInput" placeholder="Correo electrónico" />
    <input type="password" id="passwordInput" placeholder="Contraseña" />
    <button id="loginBtn">Ingresar</button>
    <button id="registerBtn">Registrarse</button>
    <p id="loginMessage" style="color:red; font-weight:bold;"></p>
  </div>

  <div id="logoutSection" style="display:none;">
    <p>Sesión iniciada como: <span id="userEmail"></span></p>
    <button id="logoutBtn">Cerrar Sesión</button>
  </div>

  <div style="margin-bottom:1rem; max-width: 900px;">
    <input type="text" id="searchInput" placeholder="Buscar Boss..." />
    <button id="filterBossesBtn">Mostrar sólo bosses que pueden spawnear</button>
  </div>

  <div class="timer-container" id="timerContainer"></div>

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>

  <script>
<script>
  // Configurá tus credenciales de Firebase
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyAizvPiX4f2hk4KFxD0J9Hm7hdfoNXz60Y",
  authDomain: "cronometroiao.firebaseapp.com",
  databaseURL: "https://cronometroiao-default-rtdb.firebaseio.com",
  projectId: "cronometroiao",
  storageBucket: "cronometroiao.firebasestorage.app",
  messagingSenderId: "906013460712",
  appId: "1:906013460712:web:fdf87311000fc2288e615d",
  measurementId: "G-K923BGRD3K"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);

  // Inicialización Firebase
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();

  // Bosses con tiempos mínimos y máximos (min y max respawn en minutos)
 const bosses = [
      { name: "Rey Dragón", minDelay: 22 * 3600 * 1000, maxDelay: 30 * 3600 * 1000 },
      { name: "Dragón Legendario", minDelay: 16 * 3600 * 1000, maxDelay: 24 * 3600 * 1000 },
      { name: "Gran Dragón Negro", minDelay: 12 * 3600 * 1000, maxDelay: 20 * 3600 * 1000 },
      { name: "Gran Dragón Rojo", minDelay: 12 * 3600 * 1000, maxDelay: 20 * 3600 * 1000 },
      { name: "Archimago Abisal", minDelay: 9 * 3600 * 1000, maxDelay: 18 * 3600 * 1000 },
      { name: "Gran Dragón Azul", minDelay: 8 * 3600 * 1000, maxDelay: 14 * 3600 * 1000 },
      { name: "Eishner", minDelay: 9 * 3600 * 1000, maxDelay: 18 * 3600 * 1000 },
      { name: "Gran Dragón Verde", minDelay: 2 * 3600 * 1000, maxDelay: 5 * 3600 * 1000 },
      { name: "Djinn", minDelay: 7 * 3600 * 1000, maxDelay: 15 * 3600 * 1000 },
      { name: "Lilith", minDelay: (2 * 3600 + 30 * 60) * 1000, maxDelay: (3 * 3600 + 30 * 60) * 1000 },
      { name: "Abyssaria", minDelay: (3 * 3600 + 30 * 60) * 1000, maxDelay: 9 * 3600 * 1000 },
      { name: "Garveloth", minDelay: 30 * 60 * 1000, maxDelay: 45 * 60 * 1000 },
      { name: "Vampiro Transformado", minDelay: 30 * 60 * 1000, maxDelay: 45 * 60 * 1000 },
      { name: "Gorgona", minDelay: (16 * 60 + 40) * 1000, maxDelay: (61 * 60) * 1000 }
    ];

  // Variables y elementos DOM
  const timerContainer = document.getElementById('timerContainer');
  const loginForm = document.getElementById('loginForm');
  const logoutSection = document.getElementById('logoutSection');
  const emailInput = document.getElementById('emailInput');
  const passwordInput = document.getElementById('passwordInput');
  const loginBtn = document.getElementById('loginBtn');
  const registerBtn = document.getElementById('registerBtn');
  const logoutBtn = document.getElementById('logoutBtn');
  const userEmailSpan = document.getElementById('userEmail');
  const loginMessage = document.getElementById('loginMessage');
  const filterBossesBtn = document.getElementById('filterBossesBtn');
  const searchInput = document.getElementById('searchInput');
  const themeToggleBtn = document.getElementById('themeToggleBtn');

  let currentUser = null;
  let showOnlyCanSpawn = false;

  // Guardar tiempos en localStorage por usuario
  function getStorageKey() {
    return currentUser ? `bossTimers_${currentUser.uid}` : null;
  }

  function loadTimers() {
    if (!currentUser) return {};
    const key = getStorageKey();
    const stored = localStorage.getItem(key);
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch {
        return {};
      }
    }
    return {};
  }

  function saveTimers(timers) {
    if (!currentUser) return;
    const key = getStorageKey();
    localStorage.setItem(key, JSON.stringify(timers));
  }

  // Crear los elementos del cronómetro para cada boss
  function createTimerElement(boss, deathTimeStr = '') {
    const timerDiv = document.createElement('div');
    timerDiv.classList.add('timer');
    timerDiv.id = `timer-${boss.id}`;

    const title = document.createElement('h2');
    title.textContent = boss.name;

    const iconSpan = document.createElement('span');
    iconSpan.classList.add('timer-icon');
    title.prepend(iconSpan);

    const respawnTimeText = document.createElement('div');
    respawnTimeText.classList.add('respawn-time');
    respawnTimeText.textContent = `${formatMinutes(boss.minRespawn)} a ${formatMinutes(boss.maxRespawn)}`;

    const timerTime = document.createElement('div');
    timerTime.classList.add('timer-time');
    timerTime.textContent = '--:--';

    // Input para la hora de muerte (solo HH:MM)
    const inputGroup = document.createElement('div');
    inputGroup.classList.add('input-group');

    const deathInput = document.createElement('input');
    deathInput.type = 'text';
    deathInput.placeholder = 'Hora muerte (HH:MM)';
    deathInput.classList.add('death-time-input');
    deathInput.maxLength = 5;
    deathInput.value = deathTimeStr;

    const btnMurio = document.createElement('button');
    btnMurio.textContent = 'Murió';
    btnMurio.classList.add('btn-murio');

    btnMurio.addEventListener('click', () => {
      if (!validateTimeFormat(deathInput.value)) {
        alert('Ingrese una hora válida en formato HH:MM');
        return;
      }
      saveBossDeathTime(boss.id, deathInput.value);
      updateTimers();
    });

    inputGroup.appendChild(deathInput);
    inputGroup.appendChild(btnMurio);

    timerDiv.appendChild(title);
    timerDiv.appendChild(respawnTimeText);
    timerDiv.appendChild(timerTime);
    timerDiv.appendChild(inputGroup);

    return timerDiv;
  }

  // Formato para minutos: si >= 60 mostrar en horas
  function formatMinutes(mins) {
    if (mins < 60) return `${mins} min`;
    else {
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      return m === 0 ? `${h} h` : `${h} h ${m} min`;
    }
  }

  // Validar formato HH:MM 24h
  function validateTimeFormat(str) {
    return /^\d{2}:\d{2}$/.test(str) && 
      Number(str.slice(0, 2)) < 24 && 
      Number(str.slice(3)) < 60;
  }

  // Guardar tiempo de muerte de un boss
  function saveBossDeathTime(bossId, timeStr) {
    const timers = loadTimers();
    timers[bossId] = timeStr;
    saveTimers(timers);
  }

  // Obtener Date del último kill basado en la hora ingresada (hoy o ayer)
  function getDeathDate(timeStr) {
    if (!validateTimeFormat(timeStr)) return null;
    const now = new Date();
    const [h, m] = timeStr.split(':').map(Number);
    let deathDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), h, m, 0);
    // Si la hora es mayor a la actual, asumimos que fue ayer
    if (deathDate > now) {
      deathDate.setDate(deathDate.getDate() - 1);
    }
    return deathDate;
  }

  // Calcular estado y tiempo restante para cada boss
  // Devuelve objeto con: status (beforeSpawn, canSpawn, spawned), timeLeftMin, icon, className
  function calcBossStatus(boss, deathTimeStr) {
    const deathDate = getDeathDate(deathTimeStr);
    if (!deathDate) {
      return { status: 'noDeath', timeLeftMin: null, icon: '', className: 'beforeSpawn' };
    }
    const now = new Date();
    const elapsedMin = (now - deathDate) / 60000;

    if (elapsedMin < boss.minRespawn) {
      return { status: 'beforeSpawn', timeLeftMin: boss.minRespawn - elapsedMin, icon: '', className: 'beforeSpawn' };
    }
    if (elapsedMin >= boss.minRespawn && elapsedMin <= boss.maxRespawn) {
      return { status: 'canSpawn', timeLeftMin: boss.maxRespawn - elapsedMin, icon: '🔥', className: 'canSpawn' };
    }
    if (elapsedMin > boss.maxRespawn) {
      return { status: 'spawned', timeLeftMin: 0, icon: '⚠️', className: 'spawned' };
    }
  }

  // Formatear tiempo mm:ss o hh:mm si es mayor a 60 min
  function formatTimeLeft(minLeft) {
    if (minLeft === null || minLeft < 0) return '--:--';
    if (minLeft >= 60) {
      const h = Math.floor(minLeft / 60);
      const m = Math.floor(minLeft % 60);
      return `${h}h ${m}m`;
    } else {
      const m = Math.floor(minLeft);
      const s = Math.floor((minLeft - m) * 60);
      return `${m}m ${s}s`;
    }
  }

  // Actualizar todos los timers
  function updateTimers() {
    const timers = loadTimers();
    bosses.forEach(boss => {
      const timerDiv = document.getElementById(`timer-${boss.id}`);
      if (!timerDiv) return;
      const deathTimeStr = timers[boss.id] || '';
      const status = calcBossStatus(boss, deathTimeStr);
      const iconSpan = timerDiv.querySelector('.timer-icon');
      const timerTime = timerDiv.querySelector('.timer-time');

      // Actualizar clases para estilos y animaciones
      timerDiv.classList.remove('beforeSpawn', 'canSpawn', 'spawned');
      timerDiv.classList.add(status.className);

      // Iconos 🔥 y ⚠️
      iconSpan.textContent = status.icon;

      // Mostrar tiempo restante
      if (status.status === 'beforeSpawn') {
        timerTime.textContent = `Faltan ${formatTimeLeft(status.timeLeftMin)}`;
      } else if (status.status === 'canSpawn') {
        timerTime.textContent = `Ventana de respawn: ${formatTimeLeft(status.timeLeftMin)}`;
      } else if (status.status === 'spawned') {
        timerTime.textContent = 'Boss spawneado!';
      } else {
        timerTime.textContent = '--:--';
      }
    });
  }

  // Renderizar todo
  function renderTimers() {
    timerContainer.innerHTML = '';
    const timers = loadTimers();

    const filterText = searchInput.value.toLowerCase();

    bosses.forEach(boss => {
      // Si hay filtro texto y no coincide el nombre, lo saltamos
      if (filterText && !boss.name.toLowerCase().includes(filterText)) return;

      // Filtro para mostrar sólo bosses que pueden spawnear (están en ventana o pasaron máximo)
      if (showOnlyCanSpawn) {
        const status = calcBossStatus(boss, timers[boss.id] || '');
        if (status.status === 'beforeSpawn' || status.status === 'noDeath') return;
      }

      const deathTimeStr = timers[boss.id] || '';
      const timerEl = createTimerElement(boss, deathTimeStr);
      timerContainer.appendChild(timerEl);
    });

    updateTimers();
  }

  // Eventos login y registro
  loginBtn.addEventListener('click', () => {
    loginMessage.textContent = '';
    const email = emailInput.value.trim();
    const pass = passwordInput.value.trim();
    if (!email || !pass) {
      loginMessage.textContent = 'Por favor, ingresa email y contraseña.';
      return;
    }
    auth.signInWithEmailAndPassword(email, pass)
      .then(cred => {
        emailInput.value = '';
        passwordInput.value = '';
        loginMessage.textContent = '';
      })
      .catch(e => {
        loginMessage.textContent = 'Error al iniciar sesión: ' + e.message;
      });
  });

  registerBtn.addEventListener('click', () => {
    loginMessage.textContent = '';
    const email = emailInput.value.trim();
    const pass = passwordInput.value.trim();
    if (!email || !pass) {
      loginMessage.textContent = 'Por favor, ingresa email y contraseña.';
      return;
    }
    auth.createUserWithEmailAndPassword(email, pass)
      .then(cred => {
        emailInput.value = '';
        passwordInput.value = '';
        loginMessage.textContent = 'Usuario registrado y logueado.';
      })
      .catch(e => {
        loginMessage.textContent = 'Error al registrar: ' + e.message;
      });
  });

  logoutBtn.addEventListener('click', () => {
    auth.signOut();
  });

  // Listener de estado de usuario
  auth.onAuthStateChanged(user => {
    currentUser = user;
    if (user) {
      loginForm.style.display = 'none';
      logoutSection.style.display = 'block';
      userEmailSpan.textContent = user.email;
      renderTimers();
    } else {
      loginForm.style.display = 'block';
      logoutSection.style.display = 'none';
      timerContainer.innerHTML = '<p>Iniciá sesión para ver y guardar los cronómetros.</p>';
    }
  });

  // Botón filtro bosses que pueden spawnear
  filterBossesBtn.addEventListener('click', () => {
    showOnlyCanSpawn = !showOnlyCanSpawn;
    filterBossesBtn.textContent = showOnlyCanSpawn ? 'Mostrar todos los bosses' : 'Mostrar sólo bosses que pueden spawnear';
    renderTimers();
  });

  // Buscar por nombre
  searchInput.addEventListener('input', () => {
    renderTimers();
  });

  // Tema claro/oscuro
  function toggleTheme() {
    document.body.classList.toggle('dark');
    // Guardar preferencia localStorage
    localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light');
  }

  // Cargar tema guardado
  window.onload = () => {
    if (localStorage.getItem('theme') === 'dark') {
      document.body.classList.add('dark');
    }
  };

  // Actualizar timers cada 10 segundos
  setInterval(() => {
    if (currentUser) updateTimers();
  }, 10000);

</script>
</body>
</html>
